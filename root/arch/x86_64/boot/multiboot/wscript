# build multiboot image
#
# (C) 2011 KATO Takeshi
#

source = [
	'cheap_alloc_use.cc',
	'entry.S',
	'log_access.cc',
	'load.cc',
	'loadinfo.cc',
	'memlog.cc',
	'postload.cc',
	'preload.cc',
]

def configure(x):
	x.find_program('objcopy', var='OBJCOPY')
	x.env.append_value('CXXFLAGS_MB', '-m32')
	x.env.append_value('DEFINES_MB', 'ARCH_IA32')
	pass

def build(x):
	target = x.path.find_or_declare('us')

	linker_script = x.path.find_node('multiboot.ld')

	ls_opt = '-Wl,-T' + linker_script.abspath()

	x.add_manual_dependency(target, linker_script)

	env = x.env.derive()
	env.append_value('ASFLAGS', '-m32')

	kobj = x.path.find_or_declare('kernel.o')
	x(
	    rule = '${OBJCOPY} -I binary -O elf32-i386 -B i386 '
	           '${SRC} ${TGT}',
	    target = kobj,
	    source = '../../kernel/kernel.bin',
	)
	source.append(kobj)

	defines = []
	if x.env.debug_boot: defines.append('DEBUG_BOOT')

	mapfile = x.path.find_or_declare('multiboot.map')
	map_opt = '-Wl,-Map,' + mapfile.abspath()

	x.program(
	    target = target,
	    source = source,
	    defines = defines,
	    cxxflags = ['-fno-exceptions', '-fno-rtti', '-mno-sse'],
	    linkflags = ['-m32', '-nostartfiles', '-static', ls_opt, map_opt],
	    env = env,
	    use = ['MB', 'mb_archlibs', 'mb_libs'],
	)



kern_defines = []

kern_includes = []

kern_asflags = []

kern_linkflags = [
    '-nostdlib', '-static',
    '-mcmodel=large'
]

kern_source = [
    '../lib/ioapic.cc',
    '../lib/mpspec.cc',
    'apic.cc',
    'global_variables.cc',
    'interrupt_entry.cc',
    'interrupt_native.S',
    'irq_control.cc',
    'kerninit.cc',
    'kernel_memory.cc',
    'physical_memory.cc',
    'serial.cc',
    'serialout.cc',
    'setupdata.cc',
    'videoout.cc',
    'cpuinit.cc',

    # for g++
    'gnuc.c',

    # for test
    'test.cc',
]

kern_asm_source = [
    'entry.S',
    'serialh.S',
    'task_switch.S',
]

def configure(conf):
	conf.find_program('lzma', var='LZMA')

def build(bld):
	kern_target = bld.path.find_or_declare('kernel.bin')

	kern_defines.extend(bld.env.common_defines)
	kern_asflags.extend(bld.env.common_asflags)

	linker_script = bld.path.find_node('kernel.ld')
	kern_linkflags.append('-T'+linker_script.abspath())
	bld.add_manual_dependency(kern_target, linker_script)

	kern_linkflags2 = [bld.env.LINK_PASS + f for f in kern_linkflags]

	map = bld.path.find_or_declare('kernel.map')
	kern_linkflags2.append('-Wl,-Map,'+map.abspath())

	# assemble-->
	kern_rule_a = '${CC} -c ${SRC} -o ${TGT} ' + ' '.join(kern_asflags)

	for asm_src in kern_asm_source:
		srcnode = bld.path.find_node(asm_src)
		objnode = srcnode.change_ext('.o')

		bld(target=objnode, source=srcnode, rule=kern_rule_a)

		# .o を kern_source に入れられないためリンクフラグに入れる。
		kern_linkflags2.append(objnode.abspath())
		bld.add_manual_dependency(kern_target, objnode);
	# <--assemble

	bld.program(features='cxx cxxprogram',
	    target   = kern_target,
	    source   = kern_source,
	    use      = ['kernel_objs', 'KERNEL'],
	    defines  = kern_defines,
	    linkflags= kern_linkflags2)

	bld(
	    target   = 'kernel.bin.lzma',
	    source   = 'kernel.bin',
	    rule     = '${LZMA} -c ${SRC} > ${TGT}')

